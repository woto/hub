version: "3.7"
services:

  elastic:
    env_file:
      - .env
    image: elasticsearch:7.4.0
    ports:
      - ${ELASTIC_REST_PORT}:9200
      - ${ELASTIC_CLUSTER_PORT}:9300
    environment:
      - discovery.type=single-node

    volumes:
      - elastic:/usr/share/elasticsearch/data

  kibana:
    env_file:
      - .env
    image: kibana:7.4.0
    ports:
      - ${KIBANA_PORT}:5601
    environment:
      - ELASTICSEARCH_HOSTS=http://elastic:9200

  mongo:
    env_file:
      - .env
    image: mongo:4.2.3
    volumes:
      - mongo:/data/db
    ports:
      - 27017:27017

  feeder:
    env_file:
      - .env
    build:
      context: ./docker/feeder
      dockerfile: Dockerfile
    volumes:
      - feeder:/app/feeds

  postgres:
    env_file:
      - .env
    build:
      context: ./docker/postgres
      dockerfile: Dockerfile
    ports:
      - ${POSTGRES_PORT}:5432
    volumes:
      - "postgres:/var/lib/postgresql/data"

  redis:
    env_file:
      - .env
    image: redis
    ports:
      - ${REDIS_PORT}:6379

  mailcatcher:
    env_file:
      - .env
    image: schickling/mailcatcher
    ports:
      - ${MAILCATCHER_WEB_PORT}:1080
      - ${MAILCATCHER_SMTP_PORT}:1025

  # To get into docker-compose network and for example
  # execute `docker-compose run --rm alpine sh -c "curl https://\$DOMAIN_NAME"
  # domain name passes from .env* files

  alpine:
    env_file:
      - .env
    build:
      context: ./docker/alpine
      dockerfile: Dockerfile
    command: echo "Alpine image is used for debugging purposes only. Run it as `docker-compose run --rm alpine sh` to get network access to other containers."
    stdin_open: true
    tty: true

networks:
  hub:

volumes:
  postgres:
  mongo:
  elastic:
  feeder:
  rails_storage:
  traefik_cert:
