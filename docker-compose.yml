version: "3.7"
services:
  traefik:
    image: "traefik:v2.0"
    ports:
      - "80:80"
      - "443:443"
      - "3035:3035"
      - "8080:8080"
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.webpacker.address=:3035
      - --providers.docker=true
      - --api.insecure=true
      # --log.level=DEBUG
      - --certificatesResolvers.myhttpchallenge.acme.email=oganer@gmail.com
      - --certificatesResolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json
      # --certificatesResolvers.myhttpchallenge.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory
      - --certificatesResolvers.myhttpchallenge.acme.httpChallenge.entryPoint=web
    labels:
      - "traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)"
      - "traefik.http.routers.http-catchall.entrypoints=web"
      - "traefik.http.routers.http-catchall.middlewares=redirect-to-https@docker"
      - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"
    volumes:
      - "./docker/traefik/letsencrypt:/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"

  # API DOCS
  swagger:
    image: swaggerapi/swagger-ui:v3.23.11
    environment:
      - BASE_URL=/swagger
      - URLS=[{"name":"swagger", "url":"/swagger/project/swagger.json"}]
      - OAUTH2_REDIRECT_URL=https://nv6.ru/swagger/oauth2-redirect.html
    volumes:
      - ./docker/swagger:/usr/share/nginx/html/project
    labels:
      - "traefik.http.routers.swagger.entrypoints=websecure"
      - "traefik.http.routers.swagger.tls.certresolver=myhttpchallenge"
      - "traefik.http.routers.swagger.rule=Host(`nv6.ru`) && PathPrefix(`/swagger/`)"
      - "traefik.http.services.swagger.loadbalancer.server.port=8080"
      - "traefik.http.routers.swagger.service=swagger"

  # MAIN APPLICATION
  rails:
    env_file:
      - .env.dev
    networks:
      default:
        aliases:
          - nv6.ru
          - en.nv6.ru
          - ru.nv6.ru
    build: .
    image: rails
    command:
      [
        "sh",
        "-c",
        "rm -f /tmp/server.pid && bin/rails s -b '0.0.0.0' --pid /tmp/server.pid",
      ]
    stdin_open: true
    tty: true
    expose:
      - 3000
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.nv6.entrypoints=websecure"
      - "traefik.http.routers.nv6.tls.certresolver=myhttpchallenge"
      - "traefik.http.routers.nv6.rule=Host(`nv6.ru`)"
      - "traefik.http.routers.ru.entrypoints=websecure"
      - "traefik.http.routers.ru.tls.certresolver=myhttpchallenge"
      - "traefik.http.routers.ru.rule=Host(`ru.nv6.ru`)"
      - "traefik.http.routers.en.entrypoints=websecure"
      - "traefik.http.routers.en.tls.certresolver=myhttpchallenge"
      - "traefik.http.routers.en.rule=Host(`en.nv6.ru`)"

  # ASSETS FOR APPLICATION
  webpacker:
    env_file:
      - .env.dev
    image: rails
    command: bin/webpack-dev-server
    expose:
      - 3035
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.webpacker.entrypoints=webpacker"
      - "traefik.http.routers.webpacker.tls.certresolver=myhttpchallenge"
      - "traefik.http.routers.webpacker.rule=Host(`nv6.ru`)"

  # E2E tests
  puppeteer:
    build:
      context: .
      dockerfile: ./docker/puppeteer/Dockerfile
    volumes:
      - "./docker/puppeteer/tests:/tests"
      - "./docker/puppeteer/screenshots:/screenshots"
    # command: "wait-for-it.sh -t 1 https://nv6.ru -- mocha --recursive /tests"
    command: "mocha --recursive /tests"

  # MONITORING
  netdata:
    image: netdata/netdata
    ports:
      - 19999:19999
    cap_add:
      - SYS_PTRACE
    security_opt:
      - apparmor:unconfined
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro

  # MAIN DATABASE
  postgres:
    env_file:
      - .env.dev
    image: postgres
    volumes:
      - "postgres:/var/lib/postgresql/data"

  # FOR WEBSOCKETS
  redis_cable:
    image: redis

  # This service may live separated per Rails application.
  # Data stored in this service should be considered as "don't be worried if it's lost"
  # because it could be retrivable from persist storages (postgres for example)
  # FOR CACHING
  redis_cache:
    image: redis

  # FOR OMNIAUTH
  redis_oauth:
    image: redis

networks:
  default:

volumes:
  postgres:
